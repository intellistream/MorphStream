// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_message_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_message_2eproto;
namespace message {
class ContinueMessage;
struct ContinueMessageDefaultTypeInternal;
extern ContinueMessageDefaultTypeInternal _ContinueMessage_default_instance_;
class MessageFromStateManager;
struct MessageFromStateManagerDefaultTypeInternal;
extern MessageFromStateManagerDefaultTypeInternal _MessageFromStateManager_default_instance_;
class MessageFromVNFInst;
struct MessageFromVNFInstDefaultTypeInternal;
extern MessageFromVNFInstDefaultTypeInternal _MessageFromVNFInst_default_instance_;
class MonitorReportMessage;
struct MonitorReportMessageDefaultTypeInternal;
extern MonitorReportMessageDefaultTypeInternal _MonitorReportMessage_default_instance_;
class PauseMessage;
struct PauseMessageDefaultTypeInternal;
extern PauseMessageDefaultTypeInternal _PauseMessage_default_instance_;
class SFCMessage;
struct SFCMessageDefaultTypeInternal;
extern SFCMessageDefaultTypeInternal _SFCMessage_default_instance_;
class TxnDoneMessage;
struct TxnDoneMessageDefaultTypeInternal;
extern TxnDoneMessageDefaultTypeInternal _TxnDoneMessage_default_instance_;
class TxnReqMessage;
struct TxnReqMessageDefaultTypeInternal;
extern TxnReqMessageDefaultTypeInternal _TxnReqMessage_default_instance_;
class UDFReadyMessage;
struct UDFReadyMessageDefaultTypeInternal;
extern UDFReadyMessageDefaultTypeInternal _UDFReadyMessage_default_instance_;
class UDFResponse;
struct UDFResponseDefaultTypeInternal;
extern UDFResponseDefaultTypeInternal _UDFResponse_default_instance_;
class getCCMessage;
struct getCCMessageDefaultTypeInternal;
extern getCCMessageDefaultTypeInternal _getCCMessage_default_instance_;
class getDSMessage;
struct getDSMessageDefaultTypeInternal;
extern getDSMessageDefaultTypeInternal _getDSMessage_default_instance_;
class setCCMessage;
struct setCCMessageDefaultTypeInternal;
extern setCCMessageDefaultTypeInternal _setCCMessage_default_instance_;
class setDSMessage;
struct setDSMessageDefaultTypeInternal;
extern setDSMessageDefaultTypeInternal _setDSMessage_default_instance_;
}  // namespace message
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace message {
enum CC : int {
  PARTITION = 0,
  CACHE = 1,
  OFFLOAD = 2,
  PREEMPTIVE = 3,
  CC_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CC_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CC_IsValid(int value);
extern const uint32_t CC_internal_data_[];
constexpr CC CC_MIN = static_cast<CC>(0);
constexpr CC CC_MAX = static_cast<CC>(3);
constexpr int CC_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
CC_descriptor();
template <typename T>
const std::string& CC_Name(T value) {
  static_assert(std::is_same<T, CC>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CC_Name().");
  return CC_Name(static_cast<CC>(value));
}
template <>
inline const std::string& CC_Name(CC value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CC_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool CC_Parse(absl::string_view name, CC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CC>(
      CC_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class setDSMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.setDSMessage) */ {
 public:
  inline setDSMessage() : setDSMessage(nullptr) {}
  ~setDSMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR setDSMessage(::google::protobuf::internal::ConstantInitialized);

  inline setDSMessage(const setDSMessage& from)
      : setDSMessage(nullptr, from) {}
  setDSMessage(setDSMessage&& from) noexcept
    : setDSMessage() {
    *this = ::std::move(from);
  }

  inline setDSMessage& operator=(const setDSMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline setDSMessage& operator=(setDSMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const setDSMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const setDSMessage* internal_default_instance() {
    return reinterpret_cast<const setDSMessage*>(
               &_setDSMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(setDSMessage& a, setDSMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(setDSMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(setDSMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  setDSMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<setDSMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const setDSMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const setDSMessage& from) {
    setDSMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(setDSMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.setDSMessage";
  }
  protected:
  explicit setDSMessage(::google::protobuf::Arena* arena);
  setDSMessage(::google::protobuf::Arena* arena, const setDSMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // int32 key = 1;
  void clear_key() ;
  ::int32_t key() const;
  void set_key(::int32_t value);

  private:
  ::int32_t _internal_key() const;
  void _internal_set_key(::int32_t value);

  public:
  // optional int32 value = 2;
  bool has_value() const;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.setDSMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int32_t key_;
    ::int32_t value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class setCCMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.setCCMessage) */ {
 public:
  inline setCCMessage() : setCCMessage(nullptr) {}
  ~setCCMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR setCCMessage(::google::protobuf::internal::ConstantInitialized);

  inline setCCMessage(const setCCMessage& from)
      : setCCMessage(nullptr, from) {}
  setCCMessage(setCCMessage&& from) noexcept
    : setCCMessage() {
    *this = ::std::move(from);
  }

  inline setCCMessage& operator=(const setCCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline setCCMessage& operator=(setCCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const setCCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const setCCMessage* internal_default_instance() {
    return reinterpret_cast<const setCCMessage*>(
               &_setCCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(setCCMessage& a, setCCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(setCCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(setCCMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  setCCMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<setCCMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const setCCMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const setCCMessage& from) {
    setCCMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(setCCMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.setCCMessage";
  }
  protected:
  explicit setCCMessage(::google::protobuf::Arena* arena);
  setCCMessage(::google::protobuf::Arena* arena, const setCCMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kCcFieldNumber = 2,
  };
  // int32 key = 1;
  void clear_key() ;
  ::int32_t key() const;
  void set_key(::int32_t value);

  private:
  ::int32_t _internal_key() const;
  void _internal_set_key(::int32_t value);

  public:
  // .message.CC cc = 2;
  void clear_cc() ;
  ::message::CC cc() const;
  void set_cc(::message::CC value);

  private:
  ::message::CC _internal_cc() const;
  void _internal_set_cc(::message::CC value);

  public:
  // @@protoc_insertion_point(class_scope:message.setCCMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t key_;
    int cc_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class getDSMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.getDSMessage) */ {
 public:
  inline getDSMessage() : getDSMessage(nullptr) {}
  ~getDSMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getDSMessage(::google::protobuf::internal::ConstantInitialized);

  inline getDSMessage(const getDSMessage& from)
      : getDSMessage(nullptr, from) {}
  getDSMessage(getDSMessage&& from) noexcept
    : getDSMessage() {
    *this = ::std::move(from);
  }

  inline getDSMessage& operator=(const getDSMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline getDSMessage& operator=(getDSMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getDSMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const getDSMessage* internal_default_instance() {
    return reinterpret_cast<const getDSMessage*>(
               &_getDSMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(getDSMessage& a, getDSMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(getDSMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getDSMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getDSMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getDSMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const getDSMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const getDSMessage& from) {
    getDSMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(getDSMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.getDSMessage";
  }
  protected:
  explicit getDSMessage(::google::protobuf::Arena* arena);
  getDSMessage(::google::protobuf::Arena* arena, const getDSMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // int32 key = 1;
  void clear_key() ;
  ::int32_t key() const;
  void set_key(::int32_t value);

  private:
  ::int32_t _internal_key() const;
  void _internal_set_key(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.getDSMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class getCCMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.getCCMessage) */ {
 public:
  inline getCCMessage() : getCCMessage(nullptr) {}
  ~getCCMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR getCCMessage(::google::protobuf::internal::ConstantInitialized);

  inline getCCMessage(const getCCMessage& from)
      : getCCMessage(nullptr, from) {}
  getCCMessage(getCCMessage&& from) noexcept
    : getCCMessage() {
    *this = ::std::move(from);
  }

  inline getCCMessage& operator=(const getCCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline getCCMessage& operator=(getCCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const getCCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const getCCMessage* internal_default_instance() {
    return reinterpret_cast<const getCCMessage*>(
               &_getCCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(getCCMessage& a, getCCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(getCCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(getCCMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  getCCMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<getCCMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const getCCMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const getCCMessage& from) {
    getCCMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(getCCMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.getCCMessage";
  }
  protected:
  explicit getCCMessage(::google::protobuf::Arena* arena);
  getCCMessage(::google::protobuf::Arena* arena, const getCCMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // int32 key = 1;
  void clear_key() ;
  ::int32_t key() const;
  void set_key(::int32_t value);

  private:
  ::int32_t _internal_key() const;
  void _internal_set_key(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.getCCMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class UDFResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.UDFResponse) */ {
 public:
  inline UDFResponse() : UDFResponse(nullptr) {}
  ~UDFResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UDFResponse(::google::protobuf::internal::ConstantInitialized);

  inline UDFResponse(const UDFResponse& from)
      : UDFResponse(nullptr, from) {}
  UDFResponse(UDFResponse&& from) noexcept
    : UDFResponse() {
    *this = ::std::move(from);
  }

  inline UDFResponse& operator=(const UDFResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDFResponse& operator=(UDFResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDFResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDFResponse* internal_default_instance() {
    return reinterpret_cast<const UDFResponse*>(
               &_UDFResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(UDFResponse& a, UDFResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UDFResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDFResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDFResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDFResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UDFResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UDFResponse& from) {
    UDFResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UDFResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.UDFResponse";
  }
  protected:
  explicit UDFResponse(::google::protobuf::Arena* arena);
  UDFResponse(::google::protobuf::Arena* arena, const UDFResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSaIdxFieldNumber = 2,
    kKeyFieldNumber = 3,
    kValueFieldNumber = 4,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // int32 saIdx = 2;
  void clear_saidx() ;
  ::int32_t saidx() const;
  void set_saidx(::int32_t value);

  private:
  ::int32_t _internal_saidx() const;
  void _internal_set_saidx(::int32_t value);

  public:
  // optional int32 key = 3;
  bool has_key() const;
  void clear_key() ;
  ::int32_t key() const;
  void set_key(::int32_t value);

  private:
  ::int32_t _internal_key() const;
  void _internal_set_key(::int32_t value);

  public:
  // optional int32 value = 4;
  bool has_value() const;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.UDFResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t id_;
    ::int32_t saidx_;
    ::int32_t key_;
    ::int32_t value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class UDFReadyMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.UDFReadyMessage) */ {
 public:
  inline UDFReadyMessage() : UDFReadyMessage(nullptr) {}
  ~UDFReadyMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UDFReadyMessage(::google::protobuf::internal::ConstantInitialized);

  inline UDFReadyMessage(const UDFReadyMessage& from)
      : UDFReadyMessage(nullptr, from) {}
  UDFReadyMessage(UDFReadyMessage&& from) noexcept
    : UDFReadyMessage() {
    *this = ::std::move(from);
  }

  inline UDFReadyMessage& operator=(const UDFReadyMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDFReadyMessage& operator=(UDFReadyMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDFReadyMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDFReadyMessage* internal_default_instance() {
    return reinterpret_cast<const UDFReadyMessage*>(
               &_UDFReadyMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(UDFReadyMessage& a, UDFReadyMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(UDFReadyMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDFReadyMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDFReadyMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDFReadyMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UDFReadyMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UDFReadyMessage& from) {
    UDFReadyMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UDFReadyMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.UDFReadyMessage";
  }
  protected:
  explicit UDFReadyMessage(::google::protobuf::Arena* arena);
  UDFReadyMessage(::google::protobuf::Arena* arena, const UDFReadyMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSaIdxFieldNumber = 2,
    kKeyFieldNumber = 3,
    kValueFieldNumber = 4,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // int32 saIdx = 2;
  void clear_saidx() ;
  ::int32_t saidx() const;
  void set_saidx(::int32_t value);

  private:
  ::int32_t _internal_saidx() const;
  void _internal_set_saidx(::int32_t value);

  public:
  // optional int32 key = 3;
  bool has_key() const;
  void clear_key() ;
  ::int32_t key() const;
  void set_key(::int32_t value);

  private:
  ::int32_t _internal_key() const;
  void _internal_set_key(::int32_t value);

  public:
  // optional int32 value = 4;
  bool has_value() const;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.UDFReadyMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint64_t id_;
    ::int32_t saidx_;
    ::int32_t key_;
    ::int32_t value_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class TxnReqMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.TxnReqMessage) */ {
 public:
  inline TxnReqMessage() : TxnReqMessage(nullptr) {}
  ~TxnReqMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TxnReqMessage(::google::protobuf::internal::ConstantInitialized);

  inline TxnReqMessage(const TxnReqMessage& from)
      : TxnReqMessage(nullptr, from) {}
  TxnReqMessage(TxnReqMessage&& from) noexcept
    : TxnReqMessage() {
    *this = ::std::move(from);
  }

  inline TxnReqMessage& operator=(const TxnReqMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxnReqMessage& operator=(TxnReqMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxnReqMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxnReqMessage* internal_default_instance() {
    return reinterpret_cast<const TxnReqMessage*>(
               &_TxnReqMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TxnReqMessage& a, TxnReqMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TxnReqMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxnReqMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxnReqMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxnReqMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TxnReqMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TxnReqMessage& from) {
    TxnReqMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TxnReqMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.TxnReqMessage";
  }
  protected:
  explicit TxnReqMessage(::google::protobuf::Arena* arena);
  TxnReqMessage(::google::protobuf::Arena* arena, const TxnReqMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kCcFieldNumber = 1,
    kSaIdxFieldNumber = 3,
    kKeyFieldNumber = 4,
  };
  // uint64 id = 2;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // .message.CC cc = 1;
  void clear_cc() ;
  ::message::CC cc() const;
  void set_cc(::message::CC value);

  private:
  ::message::CC _internal_cc() const;
  void _internal_set_cc(::message::CC value);

  public:
  // int32 saIdx = 3;
  void clear_saidx() ;
  ::int32_t saidx() const;
  void set_saidx(::int32_t value);

  private:
  ::int32_t _internal_saidx() const;
  void _internal_set_saidx(::int32_t value);

  public:
  // int32 key = 4;
  void clear_key() ;
  ::int32_t key() const;
  void set_key(::int32_t value);

  private:
  ::int32_t _internal_key() const;
  void _internal_set_key(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.TxnReqMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t id_;
    int cc_;
    ::int32_t saidx_;
    ::int32_t key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class TxnDoneMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.TxnDoneMessage) */ {
 public:
  inline TxnDoneMessage() : TxnDoneMessage(nullptr) {}
  ~TxnDoneMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TxnDoneMessage(::google::protobuf::internal::ConstantInitialized);

  inline TxnDoneMessage(const TxnDoneMessage& from)
      : TxnDoneMessage(nullptr, from) {}
  TxnDoneMessage(TxnDoneMessage&& from) noexcept
    : TxnDoneMessage() {
    *this = ::std::move(from);
  }

  inline TxnDoneMessage& operator=(const TxnDoneMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxnDoneMessage& operator=(TxnDoneMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxnDoneMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxnDoneMessage* internal_default_instance() {
    return reinterpret_cast<const TxnDoneMessage*>(
               &_TxnDoneMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TxnDoneMessage& a, TxnDoneMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(TxnDoneMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxnDoneMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxnDoneMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxnDoneMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TxnDoneMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TxnDoneMessage& from) {
    TxnDoneMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TxnDoneMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.TxnDoneMessage";
  }
  protected:
  explicit TxnDoneMessage(::google::protobuf::Arena* arena);
  TxnDoneMessage(::google::protobuf::Arena* arena, const TxnDoneMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:message.TxnDoneMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint64_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class SFCMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.SFCMessage) */ {
 public:
  inline SFCMessage() : SFCMessage(nullptr) {}
  ~SFCMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SFCMessage(::google::protobuf::internal::ConstantInitialized);

  inline SFCMessage(const SFCMessage& from)
      : SFCMessage(nullptr, from) {}
  SFCMessage(SFCMessage&& from) noexcept
    : SFCMessage() {
    *this = ::std::move(from);
  }

  inline SFCMessage& operator=(const SFCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline SFCMessage& operator=(SFCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SFCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const SFCMessage* internal_default_instance() {
    return reinterpret_cast<const SFCMessage*>(
               &_SFCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SFCMessage& a, SFCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(SFCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SFCMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SFCMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SFCMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SFCMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SFCMessage& from) {
    SFCMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SFCMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.SFCMessage";
  }
  protected:
  explicit SFCMessage(::google::protobuf::Arena* arena);
  SFCMessage(::google::protobuf::Arena* arena, const SFCMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFCJsonFieldNumber = 1,
  };
  // string SFCJson = 1;
  void clear_sfcjson() ;
  const std::string& sfcjson() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sfcjson(Arg_&& arg, Args_... args);
  std::string* mutable_sfcjson();
  PROTOBUF_NODISCARD std::string* release_sfcjson();
  void set_allocated_sfcjson(std::string* value);

  private:
  const std::string& _internal_sfcjson() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sfcjson(
      const std::string& value);
  std::string* _internal_mutable_sfcjson();

  public:
  // @@protoc_insertion_point(class_scope:message.SFCMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      34, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr sfcjson_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class PauseMessage final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:message.PauseMessage) */ {
 public:
  inline PauseMessage() : PauseMessage(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PauseMessage(::google::protobuf::internal::ConstantInitialized);

  inline PauseMessage(const PauseMessage& from)
      : PauseMessage(nullptr, from) {}
  PauseMessage(PauseMessage&& from) noexcept
    : PauseMessage() {
    *this = ::std::move(from);
  }

  inline PauseMessage& operator=(const PauseMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseMessage& operator=(PauseMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PauseMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const PauseMessage* internal_default_instance() {
    return reinterpret_cast<const PauseMessage*>(
               &_PauseMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PauseMessage& a, PauseMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PauseMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PauseMessage>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PauseMessage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PauseMessage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.PauseMessage";
  }
  protected:
  explicit PauseMessage(::google::protobuf::Arena* arena);
  PauseMessage(::google::protobuf::Arena* arena, const PauseMessage& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.PauseMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class MonitorReportMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.MonitorReportMessage) */ {
 public:
  inline MonitorReportMessage() : MonitorReportMessage(nullptr) {}
  ~MonitorReportMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MonitorReportMessage(::google::protobuf::internal::ConstantInitialized);

  inline MonitorReportMessage(const MonitorReportMessage& from)
      : MonitorReportMessage(nullptr, from) {}
  MonitorReportMessage(MonitorReportMessage&& from) noexcept
    : MonitorReportMessage() {
    *this = ::std::move(from);
  }

  inline MonitorReportMessage& operator=(const MonitorReportMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MonitorReportMessage& operator=(MonitorReportMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MonitorReportMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MonitorReportMessage* internal_default_instance() {
    return reinterpret_cast<const MonitorReportMessage*>(
               &_MonitorReportMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MonitorReportMessage& a, MonitorReportMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(MonitorReportMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MonitorReportMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MonitorReportMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MonitorReportMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MonitorReportMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MonitorReportMessage& from) {
    MonitorReportMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MonitorReportMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.MonitorReportMessage";
  }
  protected:
  explicit MonitorReportMessage(::google::protobuf::Arena* arena);
  MonitorReportMessage(::google::protobuf::Arena* arena, const MonitorReportMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCcFieldNumber = 1,
  };
  // .message.CC cc = 1;
  void clear_cc() ;
  ::message::CC cc() const;
  void set_cc(::message::CC value);

  private:
  ::message::CC _internal_cc() const;
  void _internal_set_cc(::message::CC value);

  public:
  // @@protoc_insertion_point(class_scope:message.MonitorReportMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int cc_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class ContinueMessage final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:message.ContinueMessage) */ {
 public:
  inline ContinueMessage() : ContinueMessage(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContinueMessage(::google::protobuf::internal::ConstantInitialized);

  inline ContinueMessage(const ContinueMessage& from)
      : ContinueMessage(nullptr, from) {}
  ContinueMessage(ContinueMessage&& from) noexcept
    : ContinueMessage() {
    *this = ::std::move(from);
  }

  inline ContinueMessage& operator=(const ContinueMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContinueMessage& operator=(ContinueMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContinueMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContinueMessage* internal_default_instance() {
    return reinterpret_cast<const ContinueMessage*>(
               &_ContinueMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ContinueMessage& a, ContinueMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ContinueMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContinueMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContinueMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContinueMessage>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ContinueMessage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ContinueMessage& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.ContinueMessage";
  }
  protected:
  explicit ContinueMessage(::google::protobuf::Arena* arena);
  ContinueMessage(::google::protobuf::Arena* arena, const ContinueMessage& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:message.ContinueMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class MessageFromVNFInst final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.MessageFromVNFInst) */ {
 public:
  inline MessageFromVNFInst() : MessageFromVNFInst(nullptr) {}
  ~MessageFromVNFInst() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MessageFromVNFInst(::google::protobuf::internal::ConstantInitialized);

  inline MessageFromVNFInst(const MessageFromVNFInst& from)
      : MessageFromVNFInst(nullptr, from) {}
  MessageFromVNFInst(MessageFromVNFInst&& from) noexcept
    : MessageFromVNFInst() {
    *this = ::std::move(from);
  }

  inline MessageFromVNFInst& operator=(const MessageFromVNFInst& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageFromVNFInst& operator=(MessageFromVNFInst&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageFromVNFInst& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kMonitorReportMessage = 1,
    kSfcMessage = 2,
    kTxnReqMessage = 3,
    kPushCCMessage = 4,
    kPushDSMessage = 5,
    MSG_NOT_SET = 0,
  };

  static inline const MessageFromVNFInst* internal_default_instance() {
    return reinterpret_cast<const MessageFromVNFInst*>(
               &_MessageFromVNFInst_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MessageFromVNFInst& a, MessageFromVNFInst& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageFromVNFInst* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageFromVNFInst* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageFromVNFInst* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageFromVNFInst>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageFromVNFInst& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MessageFromVNFInst& from) {
    MessageFromVNFInst::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MessageFromVNFInst* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.MessageFromVNFInst";
  }
  protected:
  explicit MessageFromVNFInst(::google::protobuf::Arena* arena);
  MessageFromVNFInst(::google::protobuf::Arena* arena, const MessageFromVNFInst& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMonitorReportMessageFieldNumber = 1,
    kSfcMessageFieldNumber = 2,
    kTxnReqMessageFieldNumber = 3,
    kPushCCMessageFieldNumber = 4,
    kPushDSMessageFieldNumber = 5,
  };
  // .message.MonitorReportMessage monitorReportMessage = 1;
  bool has_monitorreportmessage() const;
  private:
  bool _internal_has_monitorreportmessage() const;

  public:
  void clear_monitorreportmessage() ;
  const ::message::MonitorReportMessage& monitorreportmessage() const;
  PROTOBUF_NODISCARD ::message::MonitorReportMessage* release_monitorreportmessage();
  ::message::MonitorReportMessage* mutable_monitorreportmessage();
  void set_allocated_monitorreportmessage(::message::MonitorReportMessage* value);
  void unsafe_arena_set_allocated_monitorreportmessage(::message::MonitorReportMessage* value);
  ::message::MonitorReportMessage* unsafe_arena_release_monitorreportmessage();

  private:
  const ::message::MonitorReportMessage& _internal_monitorreportmessage() const;
  ::message::MonitorReportMessage* _internal_mutable_monitorreportmessage();

  public:
  // .message.SFCMessage sfcMessage = 2;
  bool has_sfcmessage() const;
  private:
  bool _internal_has_sfcmessage() const;

  public:
  void clear_sfcmessage() ;
  const ::message::SFCMessage& sfcmessage() const;
  PROTOBUF_NODISCARD ::message::SFCMessage* release_sfcmessage();
  ::message::SFCMessage* mutable_sfcmessage();
  void set_allocated_sfcmessage(::message::SFCMessage* value);
  void unsafe_arena_set_allocated_sfcmessage(::message::SFCMessage* value);
  ::message::SFCMessage* unsafe_arena_release_sfcmessage();

  private:
  const ::message::SFCMessage& _internal_sfcmessage() const;
  ::message::SFCMessage* _internal_mutable_sfcmessage();

  public:
  // .message.TxnReqMessage txnReqMessage = 3;
  bool has_txnreqmessage() const;
  private:
  bool _internal_has_txnreqmessage() const;

  public:
  void clear_txnreqmessage() ;
  const ::message::TxnReqMessage& txnreqmessage() const;
  PROTOBUF_NODISCARD ::message::TxnReqMessage* release_txnreqmessage();
  ::message::TxnReqMessage* mutable_txnreqmessage();
  void set_allocated_txnreqmessage(::message::TxnReqMessage* value);
  void unsafe_arena_set_allocated_txnreqmessage(::message::TxnReqMessage* value);
  ::message::TxnReqMessage* unsafe_arena_release_txnreqmessage();

  private:
  const ::message::TxnReqMessage& _internal_txnreqmessage() const;
  ::message::TxnReqMessage* _internal_mutable_txnreqmessage();

  public:
  // .message.setCCMessage pushCCMessage = 4;
  bool has_pushccmessage() const;
  private:
  bool _internal_has_pushccmessage() const;

  public:
  void clear_pushccmessage() ;
  const ::message::setCCMessage& pushccmessage() const;
  PROTOBUF_NODISCARD ::message::setCCMessage* release_pushccmessage();
  ::message::setCCMessage* mutable_pushccmessage();
  void set_allocated_pushccmessage(::message::setCCMessage* value);
  void unsafe_arena_set_allocated_pushccmessage(::message::setCCMessage* value);
  ::message::setCCMessage* unsafe_arena_release_pushccmessage();

  private:
  const ::message::setCCMessage& _internal_pushccmessage() const;
  ::message::setCCMessage* _internal_mutable_pushccmessage();

  public:
  // .message.setDSMessage pushDSMessage = 5;
  bool has_pushdsmessage() const;
  private:
  bool _internal_has_pushdsmessage() const;

  public:
  void clear_pushdsmessage() ;
  const ::message::setDSMessage& pushdsmessage() const;
  PROTOBUF_NODISCARD ::message::setDSMessage* release_pushdsmessage();
  ::message::setDSMessage* mutable_pushdsmessage();
  void set_allocated_pushdsmessage(::message::setDSMessage* value);
  void unsafe_arena_set_allocated_pushdsmessage(::message::setDSMessage* value);
  ::message::setDSMessage* unsafe_arena_release_pushdsmessage();

  private:
  const ::message::setDSMessage& _internal_pushdsmessage() const;
  ::message::setDSMessage* _internal_mutable_pushdsmessage();

  public:
  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:message.MessageFromVNFInst)
 private:
  class _Internal;
  void set_has_monitorreportmessage();
  void set_has_sfcmessage();
  void set_has_txnreqmessage();
  void set_has_pushccmessage();
  void set_has_pushdsmessage();

  inline bool has_msg() const;
  inline void clear_has_msg();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::message::MonitorReportMessage* monitorreportmessage_;
      ::message::SFCMessage* sfcmessage_;
      ::message::TxnReqMessage* txnreqmessage_;
      ::message::setCCMessage* pushccmessage_;
      ::message::setDSMessage* pushdsmessage_;
    } msg_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};// -------------------------------------------------------------------

class MessageFromStateManager final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.MessageFromStateManager) */ {
 public:
  inline MessageFromStateManager() : MessageFromStateManager(nullptr) {}
  ~MessageFromStateManager() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MessageFromStateManager(::google::protobuf::internal::ConstantInitialized);

  inline MessageFromStateManager(const MessageFromStateManager& from)
      : MessageFromStateManager(nullptr, from) {}
  MessageFromStateManager(MessageFromStateManager&& from) noexcept
    : MessageFromStateManager() {
    *this = ::std::move(from);
  }

  inline MessageFromStateManager& operator=(const MessageFromStateManager& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageFromStateManager& operator=(MessageFromStateManager&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageFromStateManager& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kTxnDoneMessage = 1,
    kGetCCMessage = 2,
    kSetCCMessage = 3,
    kGetDSMessage = 4,
    kSetDSMessage = 5,
    kUdfMessage = 6,
    kPauseMessage = 7,
    kContinueMessage = 8,
    MSG_NOT_SET = 0,
  };

  static inline const MessageFromStateManager* internal_default_instance() {
    return reinterpret_cast<const MessageFromStateManager*>(
               &_MessageFromStateManager_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MessageFromStateManager& a, MessageFromStateManager& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageFromStateManager* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageFromStateManager* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageFromStateManager* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageFromStateManager>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MessageFromStateManager& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MessageFromStateManager& from) {
    MessageFromStateManager::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MessageFromStateManager* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "message.MessageFromStateManager";
  }
  protected:
  explicit MessageFromStateManager(::google::protobuf::Arena* arena);
  MessageFromStateManager(::google::protobuf::Arena* arena, const MessageFromStateManager& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxnDoneMessageFieldNumber = 1,
    kGetCCMessageFieldNumber = 2,
    kSetCCMessageFieldNumber = 3,
    kGetDSMessageFieldNumber = 4,
    kSetDSMessageFieldNumber = 5,
    kUdfMessageFieldNumber = 6,
    kPauseMessageFieldNumber = 7,
    kContinueMessageFieldNumber = 8,
  };
  // .message.TxnDoneMessage txnDoneMessage = 1;
  bool has_txndonemessage() const;
  private:
  bool _internal_has_txndonemessage() const;

  public:
  void clear_txndonemessage() ;
  const ::message::TxnDoneMessage& txndonemessage() const;
  PROTOBUF_NODISCARD ::message::TxnDoneMessage* release_txndonemessage();
  ::message::TxnDoneMessage* mutable_txndonemessage();
  void set_allocated_txndonemessage(::message::TxnDoneMessage* value);
  void unsafe_arena_set_allocated_txndonemessage(::message::TxnDoneMessage* value);
  ::message::TxnDoneMessage* unsafe_arena_release_txndonemessage();

  private:
  const ::message::TxnDoneMessage& _internal_txndonemessage() const;
  ::message::TxnDoneMessage* _internal_mutable_txndonemessage();

  public:
  // .message.getCCMessage getCCMessage = 2;
  bool has_getccmessage() const;
  private:
  bool _internal_has_getccmessage() const;

  public:
  void clear_getccmessage() ;
  const ::message::getCCMessage& getccmessage() const;
  PROTOBUF_NODISCARD ::message::getCCMessage* release_getccmessage();
  ::message::getCCMessage* mutable_getccmessage();
  void set_allocated_getccmessage(::message::getCCMessage* value);
  void unsafe_arena_set_allocated_getccmessage(::message::getCCMessage* value);
  ::message::getCCMessage* unsafe_arena_release_getccmessage();

  private:
  const ::message::getCCMessage& _internal_getccmessage() const;
  ::message::getCCMessage* _internal_mutable_getccmessage();

  public:
  // .message.setCCMessage setCCMessage = 3;
  bool has_setccmessage() const;
  private:
  bool _internal_has_setccmessage() const;

  public:
  void clear_setccmessage() ;
  const ::message::setCCMessage& setccmessage() const;
  PROTOBUF_NODISCARD ::message::setCCMessage* release_setccmessage();
  ::message::setCCMessage* mutable_setccmessage();
  void set_allocated_setccmessage(::message::setCCMessage* value);
  void unsafe_arena_set_allocated_setccmessage(::message::setCCMessage* value);
  ::message::setCCMessage* unsafe_arena_release_setccmessage();

  private:
  const ::message::setCCMessage& _internal_setccmessage() const;
  ::message::setCCMessage* _internal_mutable_setccmessage();

  public:
  // .message.getDSMessage getDSMessage = 4;
  bool has_getdsmessage() const;
  private:
  bool _internal_has_getdsmessage() const;

  public:
  void clear_getdsmessage() ;
  const ::message::getDSMessage& getdsmessage() const;
  PROTOBUF_NODISCARD ::message::getDSMessage* release_getdsmessage();
  ::message::getDSMessage* mutable_getdsmessage();
  void set_allocated_getdsmessage(::message::getDSMessage* value);
  void unsafe_arena_set_allocated_getdsmessage(::message::getDSMessage* value);
  ::message::getDSMessage* unsafe_arena_release_getdsmessage();

  private:
  const ::message::getDSMessage& _internal_getdsmessage() const;
  ::message::getDSMessage* _internal_mutable_getdsmessage();

  public:
  // .message.setDSMessage setDSMessage = 5;
  bool has_setdsmessage() const;
  private:
  bool _internal_has_setdsmessage() const;

  public:
  void clear_setdsmessage() ;
  const ::message::setDSMessage& setdsmessage() const;
  PROTOBUF_NODISCARD ::message::setDSMessage* release_setdsmessage();
  ::message::setDSMessage* mutable_setdsmessage();
  void set_allocated_setdsmessage(::message::setDSMessage* value);
  void unsafe_arena_set_allocated_setdsmessage(::message::setDSMessage* value);
  ::message::setDSMessage* unsafe_arena_release_setdsmessage();

  private:
  const ::message::setDSMessage& _internal_setdsmessage() const;
  ::message::setDSMessage* _internal_mutable_setdsmessage();

  public:
  // .message.UDFReadyMessage udfMessage = 6;
  bool has_udfmessage() const;
  private:
  bool _internal_has_udfmessage() const;

  public:
  void clear_udfmessage() ;
  const ::message::UDFReadyMessage& udfmessage() const;
  PROTOBUF_NODISCARD ::message::UDFReadyMessage* release_udfmessage();
  ::message::UDFReadyMessage* mutable_udfmessage();
  void set_allocated_udfmessage(::message::UDFReadyMessage* value);
  void unsafe_arena_set_allocated_udfmessage(::message::UDFReadyMessage* value);
  ::message::UDFReadyMessage* unsafe_arena_release_udfmessage();

  private:
  const ::message::UDFReadyMessage& _internal_udfmessage() const;
  ::message::UDFReadyMessage* _internal_mutable_udfmessage();

  public:
  // .message.PauseMessage pauseMessage = 7;
  bool has_pausemessage() const;
  private:
  bool _internal_has_pausemessage() const;

  public:
  void clear_pausemessage() ;
  const ::message::PauseMessage& pausemessage() const;
  PROTOBUF_NODISCARD ::message::PauseMessage* release_pausemessage();
  ::message::PauseMessage* mutable_pausemessage();
  void set_allocated_pausemessage(::message::PauseMessage* value);
  void unsafe_arena_set_allocated_pausemessage(::message::PauseMessage* value);
  ::message::PauseMessage* unsafe_arena_release_pausemessage();

  private:
  const ::message::PauseMessage& _internal_pausemessage() const;
  ::message::PauseMessage* _internal_mutable_pausemessage();

  public:
  // .message.ContinueMessage continueMessage = 8;
  bool has_continuemessage() const;
  private:
  bool _internal_has_continuemessage() const;

  public:
  void clear_continuemessage() ;
  const ::message::ContinueMessage& continuemessage() const;
  PROTOBUF_NODISCARD ::message::ContinueMessage* release_continuemessage();
  ::message::ContinueMessage* mutable_continuemessage();
  void set_allocated_continuemessage(::message::ContinueMessage* value);
  void unsafe_arena_set_allocated_continuemessage(::message::ContinueMessage* value);
  ::message::ContinueMessage* unsafe_arena_release_continuemessage();

  private:
  const ::message::ContinueMessage& _internal_continuemessage() const;
  ::message::ContinueMessage* _internal_mutable_continuemessage();

  public:
  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:message.MessageFromStateManager)
 private:
  class _Internal;
  void set_has_txndonemessage();
  void set_has_getccmessage();
  void set_has_setccmessage();
  void set_has_getdsmessage();
  void set_has_setdsmessage();
  void set_has_udfmessage();
  void set_has_pausemessage();
  void set_has_continuemessage();

  inline bool has_msg() const;
  inline void clear_has_msg();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 8, 8,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union MsgUnion {
      constexpr MsgUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::message::TxnDoneMessage* txndonemessage_;
      ::message::getCCMessage* getccmessage_;
      ::message::setCCMessage* setccmessage_;
      ::message::getDSMessage* getdsmessage_;
      ::message::setDSMessage* setdsmessage_;
      ::message::UDFReadyMessage* udfmessage_;
      ::message::PauseMessage* pausemessage_;
      ::message::ContinueMessage* continuemessage_;
    } msg_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_message_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// MessageFromStateManager

// .message.TxnDoneMessage txnDoneMessage = 1;
inline bool MessageFromStateManager::has_txndonemessage() const {
  return msg_case() == kTxnDoneMessage;
}
inline bool MessageFromStateManager::_internal_has_txndonemessage() const {
  return msg_case() == kTxnDoneMessage;
}
inline void MessageFromStateManager::set_has_txndonemessage() {
  _impl_._oneof_case_[0] = kTxnDoneMessage;
}
inline void MessageFromStateManager::clear_txndonemessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kTxnDoneMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.txndonemessage_;
    }
    clear_has_msg();
  }
}
inline ::message::TxnDoneMessage* MessageFromStateManager::release_txndonemessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromStateManager.txnDoneMessage)
  if (msg_case() == kTxnDoneMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.txndonemessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.txndonemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::TxnDoneMessage& MessageFromStateManager::_internal_txndonemessage() const {
  return msg_case() == kTxnDoneMessage ? *_impl_.msg_.txndonemessage_ : reinterpret_cast<::message::TxnDoneMessage&>(::message::_TxnDoneMessage_default_instance_);
}
inline const ::message::TxnDoneMessage& MessageFromStateManager::txndonemessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromStateManager.txnDoneMessage)
  return _internal_txndonemessage();
}
inline ::message::TxnDoneMessage* MessageFromStateManager::unsafe_arena_release_txndonemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromStateManager.txnDoneMessage)
  if (msg_case() == kTxnDoneMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.txndonemessage_;
    _impl_.msg_.txndonemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromStateManager::unsafe_arena_set_allocated_txndonemessage(::message::TxnDoneMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_txndonemessage();
    _impl_.msg_.txndonemessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromStateManager.txnDoneMessage)
}
inline ::message::TxnDoneMessage* MessageFromStateManager::_internal_mutable_txndonemessage() {
  if (msg_case() != kTxnDoneMessage) {
    clear_msg();
    set_has_txndonemessage();
    _impl_.msg_.txndonemessage_ = CreateMaybeMessage<::message::TxnDoneMessage>(GetArena());
  }
  return _impl_.msg_.txndonemessage_;
}
inline ::message::TxnDoneMessage* MessageFromStateManager::mutable_txndonemessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::TxnDoneMessage* _msg = _internal_mutable_txndonemessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromStateManager.txnDoneMessage)
  return _msg;
}

// .message.getCCMessage getCCMessage = 2;
inline bool MessageFromStateManager::has_getccmessage() const {
  return msg_case() == kGetCCMessage;
}
inline bool MessageFromStateManager::_internal_has_getccmessage() const {
  return msg_case() == kGetCCMessage;
}
inline void MessageFromStateManager::set_has_getccmessage() {
  _impl_._oneof_case_[0] = kGetCCMessage;
}
inline void MessageFromStateManager::clear_getccmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kGetCCMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.getccmessage_;
    }
    clear_has_msg();
  }
}
inline ::message::getCCMessage* MessageFromStateManager::release_getccmessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromStateManager.getCCMessage)
  if (msg_case() == kGetCCMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.getccmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.getccmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::getCCMessage& MessageFromStateManager::_internal_getccmessage() const {
  return msg_case() == kGetCCMessage ? *_impl_.msg_.getccmessage_ : reinterpret_cast<::message::getCCMessage&>(::message::_getCCMessage_default_instance_);
}
inline const ::message::getCCMessage& MessageFromStateManager::getccmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromStateManager.getCCMessage)
  return _internal_getccmessage();
}
inline ::message::getCCMessage* MessageFromStateManager::unsafe_arena_release_getccmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromStateManager.getCCMessage)
  if (msg_case() == kGetCCMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.getccmessage_;
    _impl_.msg_.getccmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromStateManager::unsafe_arena_set_allocated_getccmessage(::message::getCCMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_getccmessage();
    _impl_.msg_.getccmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromStateManager.getCCMessage)
}
inline ::message::getCCMessage* MessageFromStateManager::_internal_mutable_getccmessage() {
  if (msg_case() != kGetCCMessage) {
    clear_msg();
    set_has_getccmessage();
    _impl_.msg_.getccmessage_ = CreateMaybeMessage<::message::getCCMessage>(GetArena());
  }
  return _impl_.msg_.getccmessage_;
}
inline ::message::getCCMessage* MessageFromStateManager::mutable_getccmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::getCCMessage* _msg = _internal_mutable_getccmessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromStateManager.getCCMessage)
  return _msg;
}

// .message.setCCMessage setCCMessage = 3;
inline bool MessageFromStateManager::has_setccmessage() const {
  return msg_case() == kSetCCMessage;
}
inline bool MessageFromStateManager::_internal_has_setccmessage() const {
  return msg_case() == kSetCCMessage;
}
inline void MessageFromStateManager::set_has_setccmessage() {
  _impl_._oneof_case_[0] = kSetCCMessage;
}
inline void MessageFromStateManager::clear_setccmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kSetCCMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.setccmessage_;
    }
    clear_has_msg();
  }
}
inline ::message::setCCMessage* MessageFromStateManager::release_setccmessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromStateManager.setCCMessage)
  if (msg_case() == kSetCCMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.setccmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.setccmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::setCCMessage& MessageFromStateManager::_internal_setccmessage() const {
  return msg_case() == kSetCCMessage ? *_impl_.msg_.setccmessage_ : reinterpret_cast<::message::setCCMessage&>(::message::_setCCMessage_default_instance_);
}
inline const ::message::setCCMessage& MessageFromStateManager::setccmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromStateManager.setCCMessage)
  return _internal_setccmessage();
}
inline ::message::setCCMessage* MessageFromStateManager::unsafe_arena_release_setccmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromStateManager.setCCMessage)
  if (msg_case() == kSetCCMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.setccmessage_;
    _impl_.msg_.setccmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromStateManager::unsafe_arena_set_allocated_setccmessage(::message::setCCMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_setccmessage();
    _impl_.msg_.setccmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromStateManager.setCCMessage)
}
inline ::message::setCCMessage* MessageFromStateManager::_internal_mutable_setccmessage() {
  if (msg_case() != kSetCCMessage) {
    clear_msg();
    set_has_setccmessage();
    _impl_.msg_.setccmessage_ = CreateMaybeMessage<::message::setCCMessage>(GetArena());
  }
  return _impl_.msg_.setccmessage_;
}
inline ::message::setCCMessage* MessageFromStateManager::mutable_setccmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::setCCMessage* _msg = _internal_mutable_setccmessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromStateManager.setCCMessage)
  return _msg;
}

// .message.getDSMessage getDSMessage = 4;
inline bool MessageFromStateManager::has_getdsmessage() const {
  return msg_case() == kGetDSMessage;
}
inline bool MessageFromStateManager::_internal_has_getdsmessage() const {
  return msg_case() == kGetDSMessage;
}
inline void MessageFromStateManager::set_has_getdsmessage() {
  _impl_._oneof_case_[0] = kGetDSMessage;
}
inline void MessageFromStateManager::clear_getdsmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kGetDSMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.getdsmessage_;
    }
    clear_has_msg();
  }
}
inline ::message::getDSMessage* MessageFromStateManager::release_getdsmessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromStateManager.getDSMessage)
  if (msg_case() == kGetDSMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.getdsmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.getdsmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::getDSMessage& MessageFromStateManager::_internal_getdsmessage() const {
  return msg_case() == kGetDSMessage ? *_impl_.msg_.getdsmessage_ : reinterpret_cast<::message::getDSMessage&>(::message::_getDSMessage_default_instance_);
}
inline const ::message::getDSMessage& MessageFromStateManager::getdsmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromStateManager.getDSMessage)
  return _internal_getdsmessage();
}
inline ::message::getDSMessage* MessageFromStateManager::unsafe_arena_release_getdsmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromStateManager.getDSMessage)
  if (msg_case() == kGetDSMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.getdsmessage_;
    _impl_.msg_.getdsmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromStateManager::unsafe_arena_set_allocated_getdsmessage(::message::getDSMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_getdsmessage();
    _impl_.msg_.getdsmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromStateManager.getDSMessage)
}
inline ::message::getDSMessage* MessageFromStateManager::_internal_mutable_getdsmessage() {
  if (msg_case() != kGetDSMessage) {
    clear_msg();
    set_has_getdsmessage();
    _impl_.msg_.getdsmessage_ = CreateMaybeMessage<::message::getDSMessage>(GetArena());
  }
  return _impl_.msg_.getdsmessage_;
}
inline ::message::getDSMessage* MessageFromStateManager::mutable_getdsmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::getDSMessage* _msg = _internal_mutable_getdsmessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromStateManager.getDSMessage)
  return _msg;
}

// .message.setDSMessage setDSMessage = 5;
inline bool MessageFromStateManager::has_setdsmessage() const {
  return msg_case() == kSetDSMessage;
}
inline bool MessageFromStateManager::_internal_has_setdsmessage() const {
  return msg_case() == kSetDSMessage;
}
inline void MessageFromStateManager::set_has_setdsmessage() {
  _impl_._oneof_case_[0] = kSetDSMessage;
}
inline void MessageFromStateManager::clear_setdsmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kSetDSMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.setdsmessage_;
    }
    clear_has_msg();
  }
}
inline ::message::setDSMessage* MessageFromStateManager::release_setdsmessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromStateManager.setDSMessage)
  if (msg_case() == kSetDSMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.setdsmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.setdsmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::setDSMessage& MessageFromStateManager::_internal_setdsmessage() const {
  return msg_case() == kSetDSMessage ? *_impl_.msg_.setdsmessage_ : reinterpret_cast<::message::setDSMessage&>(::message::_setDSMessage_default_instance_);
}
inline const ::message::setDSMessage& MessageFromStateManager::setdsmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromStateManager.setDSMessage)
  return _internal_setdsmessage();
}
inline ::message::setDSMessage* MessageFromStateManager::unsafe_arena_release_setdsmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromStateManager.setDSMessage)
  if (msg_case() == kSetDSMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.setdsmessage_;
    _impl_.msg_.setdsmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromStateManager::unsafe_arena_set_allocated_setdsmessage(::message::setDSMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_setdsmessage();
    _impl_.msg_.setdsmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromStateManager.setDSMessage)
}
inline ::message::setDSMessage* MessageFromStateManager::_internal_mutable_setdsmessage() {
  if (msg_case() != kSetDSMessage) {
    clear_msg();
    set_has_setdsmessage();
    _impl_.msg_.setdsmessage_ = CreateMaybeMessage<::message::setDSMessage>(GetArena());
  }
  return _impl_.msg_.setdsmessage_;
}
inline ::message::setDSMessage* MessageFromStateManager::mutable_setdsmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::setDSMessage* _msg = _internal_mutable_setdsmessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromStateManager.setDSMessage)
  return _msg;
}

// .message.UDFReadyMessage udfMessage = 6;
inline bool MessageFromStateManager::has_udfmessage() const {
  return msg_case() == kUdfMessage;
}
inline bool MessageFromStateManager::_internal_has_udfmessage() const {
  return msg_case() == kUdfMessage;
}
inline void MessageFromStateManager::set_has_udfmessage() {
  _impl_._oneof_case_[0] = kUdfMessage;
}
inline void MessageFromStateManager::clear_udfmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kUdfMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.udfmessage_;
    }
    clear_has_msg();
  }
}
inline ::message::UDFReadyMessage* MessageFromStateManager::release_udfmessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromStateManager.udfMessage)
  if (msg_case() == kUdfMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.udfmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.udfmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::UDFReadyMessage& MessageFromStateManager::_internal_udfmessage() const {
  return msg_case() == kUdfMessage ? *_impl_.msg_.udfmessage_ : reinterpret_cast<::message::UDFReadyMessage&>(::message::_UDFReadyMessage_default_instance_);
}
inline const ::message::UDFReadyMessage& MessageFromStateManager::udfmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromStateManager.udfMessage)
  return _internal_udfmessage();
}
inline ::message::UDFReadyMessage* MessageFromStateManager::unsafe_arena_release_udfmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromStateManager.udfMessage)
  if (msg_case() == kUdfMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.udfmessage_;
    _impl_.msg_.udfmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromStateManager::unsafe_arena_set_allocated_udfmessage(::message::UDFReadyMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_udfmessage();
    _impl_.msg_.udfmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromStateManager.udfMessage)
}
inline ::message::UDFReadyMessage* MessageFromStateManager::_internal_mutable_udfmessage() {
  if (msg_case() != kUdfMessage) {
    clear_msg();
    set_has_udfmessage();
    _impl_.msg_.udfmessage_ = CreateMaybeMessage<::message::UDFReadyMessage>(GetArena());
  }
  return _impl_.msg_.udfmessage_;
}
inline ::message::UDFReadyMessage* MessageFromStateManager::mutable_udfmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::UDFReadyMessage* _msg = _internal_mutable_udfmessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromStateManager.udfMessage)
  return _msg;
}

// .message.PauseMessage pauseMessage = 7;
inline bool MessageFromStateManager::has_pausemessage() const {
  return msg_case() == kPauseMessage;
}
inline bool MessageFromStateManager::_internal_has_pausemessage() const {
  return msg_case() == kPauseMessage;
}
inline void MessageFromStateManager::set_has_pausemessage() {
  _impl_._oneof_case_[0] = kPauseMessage;
}
inline void MessageFromStateManager::clear_pausemessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kPauseMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.pausemessage_;
    }
    clear_has_msg();
  }
}
inline ::message::PauseMessage* MessageFromStateManager::release_pausemessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromStateManager.pauseMessage)
  if (msg_case() == kPauseMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pausemessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.pausemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::PauseMessage& MessageFromStateManager::_internal_pausemessage() const {
  return msg_case() == kPauseMessage ? *_impl_.msg_.pausemessage_ : reinterpret_cast<::message::PauseMessage&>(::message::_PauseMessage_default_instance_);
}
inline const ::message::PauseMessage& MessageFromStateManager::pausemessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromStateManager.pauseMessage)
  return _internal_pausemessage();
}
inline ::message::PauseMessage* MessageFromStateManager::unsafe_arena_release_pausemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromStateManager.pauseMessage)
  if (msg_case() == kPauseMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pausemessage_;
    _impl_.msg_.pausemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromStateManager::unsafe_arena_set_allocated_pausemessage(::message::PauseMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_pausemessage();
    _impl_.msg_.pausemessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromStateManager.pauseMessage)
}
inline ::message::PauseMessage* MessageFromStateManager::_internal_mutable_pausemessage() {
  if (msg_case() != kPauseMessage) {
    clear_msg();
    set_has_pausemessage();
    _impl_.msg_.pausemessage_ = CreateMaybeMessage<::message::PauseMessage>(GetArena());
  }
  return _impl_.msg_.pausemessage_;
}
inline ::message::PauseMessage* MessageFromStateManager::mutable_pausemessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::PauseMessage* _msg = _internal_mutable_pausemessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromStateManager.pauseMessage)
  return _msg;
}

// .message.ContinueMessage continueMessage = 8;
inline bool MessageFromStateManager::has_continuemessage() const {
  return msg_case() == kContinueMessage;
}
inline bool MessageFromStateManager::_internal_has_continuemessage() const {
  return msg_case() == kContinueMessage;
}
inline void MessageFromStateManager::set_has_continuemessage() {
  _impl_._oneof_case_[0] = kContinueMessage;
}
inline void MessageFromStateManager::clear_continuemessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kContinueMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.continuemessage_;
    }
    clear_has_msg();
  }
}
inline ::message::ContinueMessage* MessageFromStateManager::release_continuemessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromStateManager.continueMessage)
  if (msg_case() == kContinueMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.continuemessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.continuemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::ContinueMessage& MessageFromStateManager::_internal_continuemessage() const {
  return msg_case() == kContinueMessage ? *_impl_.msg_.continuemessage_ : reinterpret_cast<::message::ContinueMessage&>(::message::_ContinueMessage_default_instance_);
}
inline const ::message::ContinueMessage& MessageFromStateManager::continuemessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromStateManager.continueMessage)
  return _internal_continuemessage();
}
inline ::message::ContinueMessage* MessageFromStateManager::unsafe_arena_release_continuemessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromStateManager.continueMessage)
  if (msg_case() == kContinueMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.continuemessage_;
    _impl_.msg_.continuemessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromStateManager::unsafe_arena_set_allocated_continuemessage(::message::ContinueMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_continuemessage();
    _impl_.msg_.continuemessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromStateManager.continueMessage)
}
inline ::message::ContinueMessage* MessageFromStateManager::_internal_mutable_continuemessage() {
  if (msg_case() != kContinueMessage) {
    clear_msg();
    set_has_continuemessage();
    _impl_.msg_.continuemessage_ = CreateMaybeMessage<::message::ContinueMessage>(GetArena());
  }
  return _impl_.msg_.continuemessage_;
}
inline ::message::ContinueMessage* MessageFromStateManager::mutable_continuemessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::ContinueMessage* _msg = _internal_mutable_continuemessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromStateManager.continueMessage)
  return _msg;
}

inline bool MessageFromStateManager::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void MessageFromStateManager::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline MessageFromStateManager::MsgCase MessageFromStateManager::msg_case() const {
  return MessageFromStateManager::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PauseMessage

// -------------------------------------------------------------------

// ContinueMessage

// -------------------------------------------------------------------

// TxnDoneMessage

// uint64 id = 1;
inline void TxnDoneMessage::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t TxnDoneMessage::id() const {
  // @@protoc_insertion_point(field_get:message.TxnDoneMessage.id)
  return _internal_id();
}
inline void TxnDoneMessage::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:message.TxnDoneMessage.id)
}
inline ::uint64_t TxnDoneMessage::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TxnDoneMessage::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// getCCMessage

// int32 key = 1;
inline void getCCMessage::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_ = 0;
}
inline ::int32_t getCCMessage::key() const {
  // @@protoc_insertion_point(field_get:message.getCCMessage.key)
  return _internal_key();
}
inline void getCCMessage::set_key(::int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:message.getCCMessage.key)
}
inline ::int32_t getCCMessage::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_;
}
inline void getCCMessage::_internal_set_key(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_ = value;
}

// -------------------------------------------------------------------

// setCCMessage

// int32 key = 1;
inline void setCCMessage::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_ = 0;
}
inline ::int32_t setCCMessage::key() const {
  // @@protoc_insertion_point(field_get:message.setCCMessage.key)
  return _internal_key();
}
inline void setCCMessage::set_key(::int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:message.setCCMessage.key)
}
inline ::int32_t setCCMessage::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_;
}
inline void setCCMessage::_internal_set_key(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_ = value;
}

// .message.CC cc = 2;
inline void setCCMessage::clear_cc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cc_ = 0;
}
inline ::message::CC setCCMessage::cc() const {
  // @@protoc_insertion_point(field_get:message.setCCMessage.cc)
  return _internal_cc();
}
inline void setCCMessage::set_cc(::message::CC value) {
  _internal_set_cc(value);
  // @@protoc_insertion_point(field_set:message.setCCMessage.cc)
}
inline ::message::CC setCCMessage::_internal_cc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::message::CC>(_impl_.cc_);
}
inline void setCCMessage::_internal_set_cc(::message::CC value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cc_ = value;
}

// -------------------------------------------------------------------

// getDSMessage

// int32 key = 1;
inline void getDSMessage::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_ = 0;
}
inline ::int32_t getDSMessage::key() const {
  // @@protoc_insertion_point(field_get:message.getDSMessage.key)
  return _internal_key();
}
inline void getDSMessage::set_key(::int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:message.getDSMessage.key)
}
inline ::int32_t getDSMessage::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_;
}
inline void getDSMessage::_internal_set_key(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_ = value;
}

// -------------------------------------------------------------------

// setDSMessage

// int32 key = 1;
inline void setDSMessage::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_ = 0;
}
inline ::int32_t setDSMessage::key() const {
  // @@protoc_insertion_point(field_get:message.setDSMessage.key)
  return _internal_key();
}
inline void setDSMessage::set_key(::int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:message.setDSMessage.key)
}
inline ::int32_t setDSMessage::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_;
}
inline void setDSMessage::_internal_set_key(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_ = value;
}

// optional int32 value = 2;
inline bool setDSMessage::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void setDSMessage::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t setDSMessage::value() const {
  // @@protoc_insertion_point(field_get:message.setDSMessage.value)
  return _internal_value();
}
inline void setDSMessage::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:message.setDSMessage.value)
}
inline ::int32_t setDSMessage::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void setDSMessage::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// UDFReadyMessage

// uint64 id = 1;
inline void UDFReadyMessage::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t UDFReadyMessage::id() const {
  // @@protoc_insertion_point(field_get:message.UDFReadyMessage.id)
  return _internal_id();
}
inline void UDFReadyMessage::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:message.UDFReadyMessage.id)
}
inline ::uint64_t UDFReadyMessage::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void UDFReadyMessage::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 saIdx = 2;
inline void UDFReadyMessage::clear_saidx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.saidx_ = 0;
}
inline ::int32_t UDFReadyMessage::saidx() const {
  // @@protoc_insertion_point(field_get:message.UDFReadyMessage.saIdx)
  return _internal_saidx();
}
inline void UDFReadyMessage::set_saidx(::int32_t value) {
  _internal_set_saidx(value);
  // @@protoc_insertion_point(field_set:message.UDFReadyMessage.saIdx)
}
inline ::int32_t UDFReadyMessage::_internal_saidx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.saidx_;
}
inline void UDFReadyMessage::_internal_set_saidx(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.saidx_ = value;
}

// optional int32 key = 3;
inline bool UDFReadyMessage::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UDFReadyMessage::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t UDFReadyMessage::key() const {
  // @@protoc_insertion_point(field_get:message.UDFReadyMessage.key)
  return _internal_key();
}
inline void UDFReadyMessage::set_key(::int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:message.UDFReadyMessage.key)
}
inline ::int32_t UDFReadyMessage::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_;
}
inline void UDFReadyMessage::_internal_set_key(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_ = value;
}

// optional int32 value = 4;
inline bool UDFReadyMessage::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UDFReadyMessage::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t UDFReadyMessage::value() const {
  // @@protoc_insertion_point(field_get:message.UDFReadyMessage.value)
  return _internal_value();
}
inline void UDFReadyMessage::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:message.UDFReadyMessage.value)
}
inline ::int32_t UDFReadyMessage::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void UDFReadyMessage::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// UDFResponse

// uint64 id = 1;
inline void UDFResponse::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t UDFResponse::id() const {
  // @@protoc_insertion_point(field_get:message.UDFResponse.id)
  return _internal_id();
}
inline void UDFResponse::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:message.UDFResponse.id)
}
inline ::uint64_t UDFResponse::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void UDFResponse::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 saIdx = 2;
inline void UDFResponse::clear_saidx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.saidx_ = 0;
}
inline ::int32_t UDFResponse::saidx() const {
  // @@protoc_insertion_point(field_get:message.UDFResponse.saIdx)
  return _internal_saidx();
}
inline void UDFResponse::set_saidx(::int32_t value) {
  _internal_set_saidx(value);
  // @@protoc_insertion_point(field_set:message.UDFResponse.saIdx)
}
inline ::int32_t UDFResponse::_internal_saidx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.saidx_;
}
inline void UDFResponse::_internal_set_saidx(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.saidx_ = value;
}

// optional int32 key = 3;
inline bool UDFResponse::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void UDFResponse::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int32_t UDFResponse::key() const {
  // @@protoc_insertion_point(field_get:message.UDFResponse.key)
  return _internal_key();
}
inline void UDFResponse::set_key(::int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:message.UDFResponse.key)
}
inline ::int32_t UDFResponse::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_;
}
inline void UDFResponse::_internal_set_key(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.key_ = value;
}

// optional int32 value = 4;
inline bool UDFResponse::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UDFResponse::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int32_t UDFResponse::value() const {
  // @@protoc_insertion_point(field_get:message.UDFResponse.value)
  return _internal_value();
}
inline void UDFResponse::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:message.UDFResponse.value)
}
inline ::int32_t UDFResponse::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void UDFResponse::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// MessageFromVNFInst

// .message.MonitorReportMessage monitorReportMessage = 1;
inline bool MessageFromVNFInst::has_monitorreportmessage() const {
  return msg_case() == kMonitorReportMessage;
}
inline bool MessageFromVNFInst::_internal_has_monitorreportmessage() const {
  return msg_case() == kMonitorReportMessage;
}
inline void MessageFromVNFInst::set_has_monitorreportmessage() {
  _impl_._oneof_case_[0] = kMonitorReportMessage;
}
inline void MessageFromVNFInst::clear_monitorreportmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kMonitorReportMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.monitorreportmessage_;
    }
    clear_has_msg();
  }
}
inline ::message::MonitorReportMessage* MessageFromVNFInst::release_monitorreportmessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromVNFInst.monitorReportMessage)
  if (msg_case() == kMonitorReportMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.monitorreportmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.monitorreportmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::MonitorReportMessage& MessageFromVNFInst::_internal_monitorreportmessage() const {
  return msg_case() == kMonitorReportMessage ? *_impl_.msg_.monitorreportmessage_ : reinterpret_cast<::message::MonitorReportMessage&>(::message::_MonitorReportMessage_default_instance_);
}
inline const ::message::MonitorReportMessage& MessageFromVNFInst::monitorreportmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromVNFInst.monitorReportMessage)
  return _internal_monitorreportmessage();
}
inline ::message::MonitorReportMessage* MessageFromVNFInst::unsafe_arena_release_monitorreportmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromVNFInst.monitorReportMessage)
  if (msg_case() == kMonitorReportMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.monitorreportmessage_;
    _impl_.msg_.monitorreportmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromVNFInst::unsafe_arena_set_allocated_monitorreportmessage(::message::MonitorReportMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_monitorreportmessage();
    _impl_.msg_.monitorreportmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromVNFInst.monitorReportMessage)
}
inline ::message::MonitorReportMessage* MessageFromVNFInst::_internal_mutable_monitorreportmessage() {
  if (msg_case() != kMonitorReportMessage) {
    clear_msg();
    set_has_monitorreportmessage();
    _impl_.msg_.monitorreportmessage_ = CreateMaybeMessage<::message::MonitorReportMessage>(GetArena());
  }
  return _impl_.msg_.monitorreportmessage_;
}
inline ::message::MonitorReportMessage* MessageFromVNFInst::mutable_monitorreportmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::MonitorReportMessage* _msg = _internal_mutable_monitorreportmessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromVNFInst.monitorReportMessage)
  return _msg;
}

// .message.SFCMessage sfcMessage = 2;
inline bool MessageFromVNFInst::has_sfcmessage() const {
  return msg_case() == kSfcMessage;
}
inline bool MessageFromVNFInst::_internal_has_sfcmessage() const {
  return msg_case() == kSfcMessage;
}
inline void MessageFromVNFInst::set_has_sfcmessage() {
  _impl_._oneof_case_[0] = kSfcMessage;
}
inline void MessageFromVNFInst::clear_sfcmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kSfcMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.sfcmessage_;
    }
    clear_has_msg();
  }
}
inline ::message::SFCMessage* MessageFromVNFInst::release_sfcmessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromVNFInst.sfcMessage)
  if (msg_case() == kSfcMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.sfcmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.sfcmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::SFCMessage& MessageFromVNFInst::_internal_sfcmessage() const {
  return msg_case() == kSfcMessage ? *_impl_.msg_.sfcmessage_ : reinterpret_cast<::message::SFCMessage&>(::message::_SFCMessage_default_instance_);
}
inline const ::message::SFCMessage& MessageFromVNFInst::sfcmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromVNFInst.sfcMessage)
  return _internal_sfcmessage();
}
inline ::message::SFCMessage* MessageFromVNFInst::unsafe_arena_release_sfcmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromVNFInst.sfcMessage)
  if (msg_case() == kSfcMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.sfcmessage_;
    _impl_.msg_.sfcmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromVNFInst::unsafe_arena_set_allocated_sfcmessage(::message::SFCMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_sfcmessage();
    _impl_.msg_.sfcmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromVNFInst.sfcMessage)
}
inline ::message::SFCMessage* MessageFromVNFInst::_internal_mutable_sfcmessage() {
  if (msg_case() != kSfcMessage) {
    clear_msg();
    set_has_sfcmessage();
    _impl_.msg_.sfcmessage_ = CreateMaybeMessage<::message::SFCMessage>(GetArena());
  }
  return _impl_.msg_.sfcmessage_;
}
inline ::message::SFCMessage* MessageFromVNFInst::mutable_sfcmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::SFCMessage* _msg = _internal_mutable_sfcmessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromVNFInst.sfcMessage)
  return _msg;
}

// .message.TxnReqMessage txnReqMessage = 3;
inline bool MessageFromVNFInst::has_txnreqmessage() const {
  return msg_case() == kTxnReqMessage;
}
inline bool MessageFromVNFInst::_internal_has_txnreqmessage() const {
  return msg_case() == kTxnReqMessage;
}
inline void MessageFromVNFInst::set_has_txnreqmessage() {
  _impl_._oneof_case_[0] = kTxnReqMessage;
}
inline void MessageFromVNFInst::clear_txnreqmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kTxnReqMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.txnreqmessage_;
    }
    clear_has_msg();
  }
}
inline ::message::TxnReqMessage* MessageFromVNFInst::release_txnreqmessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromVNFInst.txnReqMessage)
  if (msg_case() == kTxnReqMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.txnreqmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.txnreqmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::TxnReqMessage& MessageFromVNFInst::_internal_txnreqmessage() const {
  return msg_case() == kTxnReqMessage ? *_impl_.msg_.txnreqmessage_ : reinterpret_cast<::message::TxnReqMessage&>(::message::_TxnReqMessage_default_instance_);
}
inline const ::message::TxnReqMessage& MessageFromVNFInst::txnreqmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromVNFInst.txnReqMessage)
  return _internal_txnreqmessage();
}
inline ::message::TxnReqMessage* MessageFromVNFInst::unsafe_arena_release_txnreqmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromVNFInst.txnReqMessage)
  if (msg_case() == kTxnReqMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.txnreqmessage_;
    _impl_.msg_.txnreqmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromVNFInst::unsafe_arena_set_allocated_txnreqmessage(::message::TxnReqMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_txnreqmessage();
    _impl_.msg_.txnreqmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromVNFInst.txnReqMessage)
}
inline ::message::TxnReqMessage* MessageFromVNFInst::_internal_mutable_txnreqmessage() {
  if (msg_case() != kTxnReqMessage) {
    clear_msg();
    set_has_txnreqmessage();
    _impl_.msg_.txnreqmessage_ = CreateMaybeMessage<::message::TxnReqMessage>(GetArena());
  }
  return _impl_.msg_.txnreqmessage_;
}
inline ::message::TxnReqMessage* MessageFromVNFInst::mutable_txnreqmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::TxnReqMessage* _msg = _internal_mutable_txnreqmessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromVNFInst.txnReqMessage)
  return _msg;
}

// .message.setCCMessage pushCCMessage = 4;
inline bool MessageFromVNFInst::has_pushccmessage() const {
  return msg_case() == kPushCCMessage;
}
inline bool MessageFromVNFInst::_internal_has_pushccmessage() const {
  return msg_case() == kPushCCMessage;
}
inline void MessageFromVNFInst::set_has_pushccmessage() {
  _impl_._oneof_case_[0] = kPushCCMessage;
}
inline void MessageFromVNFInst::clear_pushccmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kPushCCMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.pushccmessage_;
    }
    clear_has_msg();
  }
}
inline ::message::setCCMessage* MessageFromVNFInst::release_pushccmessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromVNFInst.pushCCMessage)
  if (msg_case() == kPushCCMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pushccmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.pushccmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::setCCMessage& MessageFromVNFInst::_internal_pushccmessage() const {
  return msg_case() == kPushCCMessage ? *_impl_.msg_.pushccmessage_ : reinterpret_cast<::message::setCCMessage&>(::message::_setCCMessage_default_instance_);
}
inline const ::message::setCCMessage& MessageFromVNFInst::pushccmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromVNFInst.pushCCMessage)
  return _internal_pushccmessage();
}
inline ::message::setCCMessage* MessageFromVNFInst::unsafe_arena_release_pushccmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromVNFInst.pushCCMessage)
  if (msg_case() == kPushCCMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pushccmessage_;
    _impl_.msg_.pushccmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromVNFInst::unsafe_arena_set_allocated_pushccmessage(::message::setCCMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_pushccmessage();
    _impl_.msg_.pushccmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromVNFInst.pushCCMessage)
}
inline ::message::setCCMessage* MessageFromVNFInst::_internal_mutable_pushccmessage() {
  if (msg_case() != kPushCCMessage) {
    clear_msg();
    set_has_pushccmessage();
    _impl_.msg_.pushccmessage_ = CreateMaybeMessage<::message::setCCMessage>(GetArena());
  }
  return _impl_.msg_.pushccmessage_;
}
inline ::message::setCCMessage* MessageFromVNFInst::mutable_pushccmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::setCCMessage* _msg = _internal_mutable_pushccmessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromVNFInst.pushCCMessage)
  return _msg;
}

// .message.setDSMessage pushDSMessage = 5;
inline bool MessageFromVNFInst::has_pushdsmessage() const {
  return msg_case() == kPushDSMessage;
}
inline bool MessageFromVNFInst::_internal_has_pushdsmessage() const {
  return msg_case() == kPushDSMessage;
}
inline void MessageFromVNFInst::set_has_pushdsmessage() {
  _impl_._oneof_case_[0] = kPushDSMessage;
}
inline void MessageFromVNFInst::clear_pushdsmessage() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (msg_case() == kPushDSMessage) {
    if (GetArena() == nullptr) {
      delete _impl_.msg_.pushdsmessage_;
    }
    clear_has_msg();
  }
}
inline ::message::setDSMessage* MessageFromVNFInst::release_pushdsmessage() {
  // @@protoc_insertion_point(field_release:message.MessageFromVNFInst.pushDSMessage)
  if (msg_case() == kPushDSMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pushdsmessage_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.msg_.pushdsmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::message::setDSMessage& MessageFromVNFInst::_internal_pushdsmessage() const {
  return msg_case() == kPushDSMessage ? *_impl_.msg_.pushdsmessage_ : reinterpret_cast<::message::setDSMessage&>(::message::_setDSMessage_default_instance_);
}
inline const ::message::setDSMessage& MessageFromVNFInst::pushdsmessage() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.MessageFromVNFInst.pushDSMessage)
  return _internal_pushdsmessage();
}
inline ::message::setDSMessage* MessageFromVNFInst::unsafe_arena_release_pushdsmessage() {
  // @@protoc_insertion_point(field_unsafe_arena_release:message.MessageFromVNFInst.pushDSMessage)
  if (msg_case() == kPushDSMessage) {
    clear_has_msg();
    auto* temp = _impl_.msg_.pushdsmessage_;
    _impl_.msg_.pushdsmessage_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MessageFromVNFInst::unsafe_arena_set_allocated_pushdsmessage(::message::setDSMessage* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_msg();
  if (value) {
    set_has_pushdsmessage();
    _impl_.msg_.pushdsmessage_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:message.MessageFromVNFInst.pushDSMessage)
}
inline ::message::setDSMessage* MessageFromVNFInst::_internal_mutable_pushdsmessage() {
  if (msg_case() != kPushDSMessage) {
    clear_msg();
    set_has_pushdsmessage();
    _impl_.msg_.pushdsmessage_ = CreateMaybeMessage<::message::setDSMessage>(GetArena());
  }
  return _impl_.msg_.pushdsmessage_;
}
inline ::message::setDSMessage* MessageFromVNFInst::mutable_pushdsmessage() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::message::setDSMessage* _msg = _internal_mutable_pushdsmessage();
  // @@protoc_insertion_point(field_mutable:message.MessageFromVNFInst.pushDSMessage)
  return _msg;
}

inline bool MessageFromVNFInst::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void MessageFromVNFInst::clear_has_msg() {
  _impl_._oneof_case_[0] = MSG_NOT_SET;
}
inline MessageFromVNFInst::MsgCase MessageFromVNFInst::msg_case() const {
  return MessageFromVNFInst::MsgCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MonitorReportMessage

// .message.CC cc = 1;
inline void MonitorReportMessage::clear_cc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cc_ = 0;
}
inline ::message::CC MonitorReportMessage::cc() const {
  // @@protoc_insertion_point(field_get:message.MonitorReportMessage.cc)
  return _internal_cc();
}
inline void MonitorReportMessage::set_cc(::message::CC value) {
  _internal_set_cc(value);
  // @@protoc_insertion_point(field_set:message.MonitorReportMessage.cc)
}
inline ::message::CC MonitorReportMessage::_internal_cc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::message::CC>(_impl_.cc_);
}
inline void MonitorReportMessage::_internal_set_cc(::message::CC value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cc_ = value;
}

// -------------------------------------------------------------------

// SFCMessage

// string SFCJson = 1;
inline void SFCMessage::clear_sfcjson() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sfcjson_.ClearToEmpty();
}
inline const std::string& SFCMessage::sfcjson() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:message.SFCMessage.SFCJson)
  return _internal_sfcjson();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SFCMessage::set_sfcjson(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sfcjson_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:message.SFCMessage.SFCJson)
}
inline std::string* SFCMessage::mutable_sfcjson() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sfcjson();
  // @@protoc_insertion_point(field_mutable:message.SFCMessage.SFCJson)
  return _s;
}
inline const std::string& SFCMessage::_internal_sfcjson() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sfcjson_.Get();
}
inline void SFCMessage::_internal_set_sfcjson(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.sfcjson_.Set(value, GetArena());
}
inline std::string* SFCMessage::_internal_mutable_sfcjson() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.sfcjson_.Mutable( GetArena());
}
inline std::string* SFCMessage::release_sfcjson() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:message.SFCMessage.SFCJson)
  return _impl_.sfcjson_.Release();
}
inline void SFCMessage::set_allocated_sfcjson(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sfcjson_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sfcjson_.IsDefault()) {
          _impl_.sfcjson_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:message.SFCMessage.SFCJson)
}

// -------------------------------------------------------------------

// TxnReqMessage

// .message.CC cc = 1;
inline void TxnReqMessage::clear_cc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.cc_ = 0;
}
inline ::message::CC TxnReqMessage::cc() const {
  // @@protoc_insertion_point(field_get:message.TxnReqMessage.cc)
  return _internal_cc();
}
inline void TxnReqMessage::set_cc(::message::CC value) {
  _internal_set_cc(value);
  // @@protoc_insertion_point(field_set:message.TxnReqMessage.cc)
}
inline ::message::CC TxnReqMessage::_internal_cc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::message::CC>(_impl_.cc_);
}
inline void TxnReqMessage::_internal_set_cc(::message::CC value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.cc_ = value;
}

// uint64 id = 2;
inline void TxnReqMessage::clear_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t TxnReqMessage::id() const {
  // @@protoc_insertion_point(field_get:message.TxnReqMessage.id)
  return _internal_id();
}
inline void TxnReqMessage::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:message.TxnReqMessage.id)
}
inline ::uint64_t TxnReqMessage::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_;
}
inline void TxnReqMessage::_internal_set_id(::uint64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_ = value;
}

// int32 saIdx = 3;
inline void TxnReqMessage::clear_saidx() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.saidx_ = 0;
}
inline ::int32_t TxnReqMessage::saidx() const {
  // @@protoc_insertion_point(field_get:message.TxnReqMessage.saIdx)
  return _internal_saidx();
}
inline void TxnReqMessage::set_saidx(::int32_t value) {
  _internal_set_saidx(value);
  // @@protoc_insertion_point(field_set:message.TxnReqMessage.saIdx)
}
inline ::int32_t TxnReqMessage::_internal_saidx() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.saidx_;
}
inline void TxnReqMessage::_internal_set_saidx(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.saidx_ = value;
}

// int32 key = 4;
inline void TxnReqMessage::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_ = 0;
}
inline ::int32_t TxnReqMessage::key() const {
  // @@protoc_insertion_point(field_get:message.TxnReqMessage.key)
  return _internal_key();
}
inline void TxnReqMessage::set_key(::int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:message.TxnReqMessage.key)
}
inline ::int32_t TxnReqMessage::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_;
}
inline void TxnReqMessage::_internal_set_key(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace message


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::message::CC> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::message::CC>() {
  return ::message::CC_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_message_2eproto_2epb_2eh
